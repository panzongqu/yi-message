'use strict';
var http = require('http');
var https = require('https');
var url = require('url');
var fs = require('fs');
var EventEmitter = require('events').EventEmitter;

const SUFIX = ".weaDownload";
const REQ_TIMEOUT = 30*1000;
const ERR_MAX = 5;
const REDIRECT_MAX = 5;
const HTTP_BROTHER = {'http:': http, 'https:': https};
var Downloader = function() {

	var that = new EventEmitter();
	var emit_flag = new Array(11);
	var _self = this;
	
	function request(outputDir, filename, filesize) {
		var urlObj = _self.urlObj;
		if(!HTTP_BROTHER[urlObj.protocol]){
			that.emit('error', new Error('[PROTOCAL NOT SUPPORTED] '));
			return;
		}
		// initialize begin
		var errorNum = 0;
		var redirectNum = 0;
		var options = {
			protocol: urlObj.protocol,
			hostname: urlObj.hostname,
			port: urlObj.port || (urlObj.protocol === 'https:' ? 443: 80),
			path: urlObj.path,
			rejectUnauthorized: false,
			requestCert: false
		}
		// initialize end
    	var req = HTTP_BROTHER[urlObj.protocol].get(options, function (res) {
			if (res.statusCode === 200 || res.statusCode === 206) {
				var tmpPath = outputDir + filename + SUFIX;
				var destPath = outputDir + filename;
        		var downloadfile = fs.createWriteStream(tmpPath, {
					flags: 'a',
					encoding: 'binary'
				});

				res.on('error', function (err) {
					that.emit('error', '[FILE DOWNLOAD ERROR - DATA] ' + err);
				});

				var receivedsize = 0;
				var totalsize = parseInt(res.headers['content-length'] || 0);
				// content-length is not exist
				if(totalsize === 0) {
					totalsize = filesize;
				} 
				// reset emit_flag
				reset_emit_flag();
				res.pipe(downloadfile);
				res.on('data', function (chunk) {
					// downloadfile.write(chunk);
					var chunksize = chunk.length;
					receivedsize += chunksize;
					var percent = receivedsize / totalsize;
					var hold = Math.floor(percent * 10);
					// Resolve event block
					if(!emit_flag[hold]){
						emit_flag[hold] = true;
						that.emit('progress', percent, receivedsize, totalsize);
					}
				});
				res.on('end', function () {
					downloadfile.end();
					// delete local temporary file
					if(that.status === 'ABORTED') {
						fs.unlink(tmpPath, function(err) {
							if(err) {
								that.emit('error', err);
							}
						});
					}else {
						fs.rename(tmpPath, destPath, function(err){
							if(err) {
								that.emit('error', err);
							}else{
								that.status = "OK";
								that.emit('done', outputDir + filename, that.status);
							}
						});
						
					}
				});
      		} else if(res.statusCode === 301 || res.statusCode === 302) {
				redirectNum++;
				if (redirectNum > REDIRECT_MAX) {
					that.emit('error', new Error('[REDIRECT TOO MANY]'));
				} else {
					// request redirect url
					var redirectUrlObj = url.parse(res.headers.location);
					_self.urlObj = redirectUrlObj;
					request(outputDir, filename, filesize);
				}
			} else {
				that.emit('error', '[REQUEST FAILED] ' + res.statusCode );
      		}
    	});
		// request error
		req.on('error', function(err){
			errorNum++;
			if(errorNum > ERR_MAX){
				that.emit('error', err);
			}else{
				// handle error 
				let errorCode = err.code;
				if(errorCode == "EPROTO") {
					// switch protocal
					switch_protocal();
					request(outputDir, filename, filesize);
				}else{
					that.emit('error', err);
				}
			}
		});
		// request timeout
		req.setTimeout(REQ_TIMEOUT, function(){
			that.emit('error', '[REQUEST TIMEOUT] ');
		});
		// abort pause resume
		that.pause = function() {
			// FIXME
		}

		that.resume = function() {
			// FIXME
		}

		that.abort = function() {
			req && req.abort();
			that.status = "ABORTED";
		}
  	}

  	function download(theUrl, outputDir, filesize) {
		outputDir = outputDir.replace(/\\/g, '/');
		var outputDirSlice = outputDir.split("/");
		var filename = outputDirSlice.pop();
		outputDir = outputDirSlice.join('/') + '/' || './';
		// parse url
		var urlObj = url.parse(theUrl);
		// parse url end 
		_self.urlObj = urlObj;
    	request(outputDir, filename, filesize);
  	}

	function reset_emit_flag(){
		for(var i = 0; i < emit_flag.length; ++i){
			emit_flag[i] = false;
		}
	}

	function switch_protocal(){
		let urlObj = _self.urlObj;
		if(urlObj){
			if(urlObj.protocol === 'http:'){
				urlObj.protocol = 'https:';
				// if the port is 80, change to 443
				if(urlObj.port == 80){
					urlObj.port = 443;
				}
			}else{
				urlObj.protocol = 'http:';
				// if the port is 443, change to 80
				if(urlObj.port == 443){
					urlObj.port = 80;
				}
			}
		} 
		_self.urlObj = urlObj;
	}

  	that.download = download;
 	// require('util').inherits(that, EventEmitter);
  	return that;
};

module.exports = Downloader;

